/*******************************************************************************
 * Copyright (c) 2011, Chair of Distributed Information Systems, University of Passau. 
 * All rights reserved. 
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met: 
 * 
 * 1. Redistributions of source code must retain the above copyright notice, 
 *     this list of conditions and the following disclaimer. 
 * 
 * 2. Redistributions in binary form must reproduce the above copyright 
 *     notice, this list of conditions and the following disclaimer in the 
 *     documentation and/or other materials provided with the distribution. 
 * 
 * 3. Neither the name of the University of Passau nor the names of its 
 *     contributors may be used to endorse or promote products derived 
 *     from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 ******************************************************************************/
package tpc.h.generators;

import java.io.IOException;

import pdgf.core.FieldValueDTO;
import pdgf.core.dataGenerator.GenerationContext;
import pdgf.core.dbSchema.Table;
import pdgf.core.exceptions.ConfigurationException;
import pdgf.core.exceptions.XmlException;
import pdgf.plugin.Generator;
import pdgf.util.PseudoTextGenerator;
import pdgf.plugin.AbstractPDGFRandom;
import pdgf.util.random.PdgfDefaultRandom;
import pdgf.util.random.RandomFactory;

/**
 * 
 * @author Michael Frank
 * @version 1.0 08.06.2010
 */
public class TextString_S_Comment extends Generator {

	private final static int SPREAD_MIN = 4;
	private final static int SPREAD_MAX = 16;
	private final static int SPREAD = SPREAD_MAX - SPREAD_MIN;
	private static PseudoTextGenerator ptg = null;

	private long[] complaints_rows, recommends_rows;
	private static char[] CUSTOMER = "Customer".toCharArray();
	private static char[] COMPLAINTS = "Complaints".toCharArray();
	private static char[] RECOMMENDS = "Recommends".toCharArray();
	private StringBuilder text = new StringBuilder();

	/*
	 * 
	 * private ThreadLocal<StringBuilder> perThreadStringBuilder = new
	 * ThreadLocal<StringBuilder>() {
	 * 
	 * @Override protected StringBuilder initialValue() {
	 * 
	 * return new StringBuilder(); } };
	 */
	public TextString_S_Comment() throws IOException, ConfigurationException, XmlException {
		super(
				"Special textstring for TPCH S_COMMENT field. SF * 5 rows are randomly selected to hold at a random position a string matching \"Customer%Complaints\". Another SF * 5 rows are randomly selected to hold at a random position a string matching \"Customer%Recommends\", where % is a wildcard that denotes zero or more characters. rThe term text string[x] represents a string generated by the pseudo text grammar defined in Clause 4.2.2.14. The length of the string is a random value [0.4 x .. 1.6 x] rounded up to the next integer. The output of the pseudo text grammar is truncated at the selected length.");
		ptg = PseudoTextGenerator.instance();
	}

	@Override
	public synchronized void initialize(int workers)
			throws ConfigurationException, XmlException {
		// TODO Auto-generated method stub
		super.initialize(workers);
		Table parentTable = this.getParentField().getParent();
		int sf_5 = (int) (parentTable.getParent().getScaleFactor() * 5);
		long rows = parentTable.getSize();
		complaints_rows = new long[sf_5];
		recommends_rows = new long[sf_5];

		PdgfDefaultRandom r = (PdgfDefaultRandom) this.getRNG(0);
		if (r == null) {
			try {
				r = (PdgfDefaultRandom) RandomFactory.instance().getRNGClass(
						this.getRngName());
			} catch (ClassNotFoundException e) {
				throw new pdgf.core.exceptions.XmlException(e);
			}
			r.setSeed(parentTable.getParent().getSeed());
		}

		long randRow;
		int rowsDone_complaints = 0;
		int rowsDone_recommends = 0;

		// do while both complaints and recomends are not full
		while (rowsDone_complaints < sf_5 && rowsDone_recommends < sf_5) {
			randRow = nextRandRow(rows, r);

			// put rand row into complaints, if complaints is full or not unique
			// put into recomends
			if (rowsDone_complaints < sf_5
					&& isUniqeWithin(randRow, rowsDone_complaints,
							complaints_rows)) {
				complaints_rows[rowsDone_complaints++] = randRow;
			} else if (rowsDone_recommends < sf_5
					&& isUniqeWithin(randRow, rowsDone_recommends,
							recommends_rows)) {
				recommends_rows[rowsDone_recommends++] = randRow;
			}
		}
	}

	private long nextRandRow(long rows, PdgfDefaultRandom r) {
		long randRow = r.nextLong() % rows;// a rand long between 0 and rows
		if (randRow < 0) {
			randRow = -randRow;
		}
		return randRow;
	}

	/**
	 * false if a duplicate exists.
	 * 
	 * @param row
	 * @param rowsDone
	 *            must be between 0 and complaints.length
	 * @return
	 */
	private boolean isUniqeWithin(long row, int rowsDone, long array[]) {
		for (int i = 0; i < rowsDone; i++) {
			// duplicate found
			if (array[i] == row) {
				return false;
			}
		}
		return true;
	}

	@Override
	protected void configParsers() throws XmlException {
		super.configParsers();
		
		getNodeParser(NODE_PARSER_size).setRequired(true);
	}

	@Override
	public void nextValue(AbstractPDGFRandom rng,
			GenerationContext generationContext, FieldValueDTO currentFieldValue) {
		/*
		 * text string[x],length of the string is random value [0.4 x .. 1.6x]
		 * rounded up to the next integer. getSize() is x
		 */

		int len = (int) getSize() * (SPREAD_MIN + rng.nextInt(SPREAD + 1));
		len = (len % 10) == 0 ? len / 10 : (len / 10) + 1;

		// DEBUG
		// System.out.println("size: " + getSize() + "\tlen: " + len +
		// "\t spread: " + SPREAD);
		//		
		// for (int i = 0; i < 100; i++) {
		// int next = rng.nextInt(SPREAD+1);
		// len = (int) getSize() * (SPREAD_MIN + next);
		// len = (len % 10) == 0 ? len / 10 : (len / 10) + 1;
		// System.out.println("cur spread val:" +next + "\tresultinglen" +len);
		// }

		// get per thread string builder and reset it
		// StringBuilder text = perThreadStringBuilder.get();
		// text.delete(0, text.length());

		// reset
		text.setLength(0);

		// check if this is a complaints row
		boolean isComplaint = false;
		boolean isRecommend = false;
		for (int i = 0; i < complaints_rows.length; i++) {
			//getID == getCurRow 
			if (generationContext.getID() == complaints_rows[i]) {
				isComplaint = true;
			}
			if (generationContext.getID() == recommends_rows[i]) {
				isRecommend = true;
			}
		}

		// fill Strinbuilder till final length is reached
		if (isComplaint || isRecommend) {

			// as COMPLAINTS.length == RECOMMENDS.length this works for both
			while (text.length() < (len - (COMPLAINTS.length + CUSTOMER.length))) {
				ptg.newSentence(text, rng);
			}
		} else {
			while (text.length() < len) {
				ptg.newSentence(text, rng);
			}
		}

		// insert customer complaints
		if (isComplaint) {
			// is a complaints row. insert complaint
			int lastPossibleStart = len - (COMPLAINTS.length + CUSTOMER.length);
			int startCUSTOMER = rng.nextInt(lastPossibleStart);
			text.insert(startCUSTOMER, CUSTOMER);

			// no space between "customer" and "complaints"
			int startComplaints = startCUSTOMER + CUSTOMER.length;

			// if there can be space between Custormer % Complaints determine
			// his size
			if (startCUSTOMER != lastPossibleStart) {

				lastPossibleStart = len - (startComplaints + COMPLAINTS.length);
				startComplaints += rng.nextInt(lastPossibleStart);// add space

			}
			text.insert(startComplaints, COMPLAINTS);
		}

		// insert customer recommends
		if (isRecommend) {
			// is a complaints row. insert complaint
			int lastPossibleStart = len - (RECOMMENDS.length + CUSTOMER.length);
			int startCUSTOMER = rng.nextInt(lastPossibleStart);
			text.insert(startCUSTOMER, CUSTOMER);

			// no space between "customer" and "recommends"
			int startRecommends = startCUSTOMER + CUSTOMER.length;

			// if there can be space between Custormer % Complaints determine
			// his size
			if (startCUSTOMER != lastPossibleStart) {

				lastPossibleStart = len - (startRecommends + RECOMMENDS.length);
				startRecommends += rng.nextInt(lastPossibleStart);// add space

			}
			text.insert(startRecommends, RECOMMENDS);
		}

		char[] value = new char[len];
		text.getChars(0, len, value, 0);
		currentFieldValue.setValue(value);
		// currentFieldValue.setValue(text.substring(0, len));

	}

}
