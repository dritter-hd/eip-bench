/*******************************************************************************
 * Copyright (c) 2011, Chair of Distributed Information Systems, University of Passau. 
 * All rights reserved. 
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met: 
 * 
 * 1. Redistributions of source code must retain the above copyright notice, 
 *     this list of conditions and the following disclaimer. 
 * 
 * 2. Redistributions in binary form must reproduce the above copyright 
 *     notice, this list of conditions and the following disclaimer in the 
 *     documentation and/or other materials provided with the distribution. 
 * 
 * 3. Neither the name of the University of Passau nor the names of its 
 *     contributors may be used to endorse or promote products derived 
 *     from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 ******************************************************************************/
package tpc.h.generators;

import org.w3c.dom.Node;

import pdgf.core.FieldValueDTO;
import pdgf.core.dataGenerator.GenerationContext;
import pdgf.core.Parser;
import pdgf.core.dbSchema.Field;
import pdgf.core.exceptions.ConfigurationException;
import pdgf.core.exceptions.XmlException;
import pdgf.plugin.Generator;
import pdgf.util.Constants;
import pdgf.plugin.AbstractPDGFRandom;
import pdgf.util.random.PdgfDefaultRandom;

/**
 * 
 * @author Michael Frank
 * @version 1.0 08.06.2010
 */
public class TextAppendedWithDigit extends Generator {

	public static final String NODE_PARSER_text = "text";
	public static final String NODE_PARSER_digitSrc = "digitSource";
	public static final String NODE_PARSER_cache = "cache";
	private final static char seperator = '#';
	private String text = "";
	private String digitSource = "";
	private Field source = null;
	private boolean cache = false;
	private StringBuilder textAndDigit = new StringBuilder();
	private int lastDigitValue;
	private int constantLenght;

	public static void main(String[] args) throws ConfigurationException,
			XmlException {
		TextAppendedWithDigit t = new TextAppendedWithDigit();
		t.setText("foo");
		t.setMin(10);
		t.setMax(50);
		t.setRngName("pdgf.util.random.PdgfDefaultRandom");

		t.initialize(1);
		FieldValueDTO fwdto = new FieldValueDTO(java.sql.Types.INTEGER, null);
		PdgfDefaultRandom rng = new PdgfDefaultRandom();
		GenerationContext gc = new GenerationContext();
		for (int i = 1; i < 100; i++) {
			gc.setCurrentRow(i);
			gc.setID(i);
			t.getNextValue(rng, gc, fwdto);
			System.out.println(i + ": " + fwdto.getValue());
		}

	}

	/*
	 * private ThreadLocal<StringBuilder> perThreadStringBuilder = new
	 * ThreadLocal<StringBuilder>() {
	 * 
	 * @Override protected StringBuilder initialValue() { return new
	 * StringBuilder(); } };
	 * 
	 * private ThreadLocal<Integer> perThreadLastDigitValue = new
	 * ThreadLocal<Integer>() {
	 * 
	 * @Override protected Integer initialValue() { return new Integer(0); } };
	 * 
	 * private ThreadLocal<Boolean> perThreadStringBuilderInitialized = new
	 * ThreadLocal<Boolean>() {
	 * 
	 * @Override protected Boolean initialValue() { return new Boolean(false); }
	 * };
	 */
	public TextAppendedWithDigit() throws ConfigurationException, XmlException {
		super(
				"The notation text appended with digit [text, x] represents a string generated by concatenating the sub-string text, the character \"#\", and the sub-string representation of the number x.");
		// TODO Auto-generated constructor stub
	}

	@Override
	public synchronized void initialize(int workers)
			throws ConfigurationException, XmlException {
		// TODO Auto-generated method stub
		super.initialize(workers);

		if ((min != Constants.LONG_NOT_SET && max == Constants.LONG_NOT_SET)
				|| (min == Constants.LONG_NOT_SET && max != Constants.LONG_NOT_SET)) {
			throw new XmlException(
					this.getNodeInfo()
							+ " Nodes: <"
							+ NODE_PARSER_min
							+ "> and <"
							+ NODE_PARSER_max
							+ "> belong together but only for one of them a value was specified ");
		}

		if (min != Constants.LONG_NOT_SET && max != Constants.LONG_NOT_SET
				&& min >= max) {
			throw new XmlException(this.getNodeInfo() + " Value of node <"
					+ NODE_PARSER_min + ">(" + min + ") is >= value of <"
					+ NODE_PARSER_max + ">(" + max + ")");
		}

		if (digitSource != null && !digitSource.isEmpty()) {
			Field f = this.getParentField().getParent().getField(digitSource);
			if (f == null) {
				throw new XmlException(this.getNodeInfo() + "<"
						+ NODE_PARSER_digitSrc
						+ ">  digit source or filed name  \"" + digitSource
						+ "\" is unkonwn");
			} else {
				source = f;
			}
		}

		// initialize static part of TextAppendedWith digit;
		textAndDigit.append(text);
		textAndDigit.append(seperator);
		constantLenght = textAndDigit.length();
	}

	@Override
	public void nextValue(AbstractPDGFRandom rng, GenerationContext gc,
			FieldValueDTO currentFieldValue) {
		// StringBuilder textAndDigit = perThreadStringBuilder.get();

		// erase appendet digit value, keep static text + seperator
		textAndDigit.setLength(constantLenght);

		// append from a digit source (foreign key in same table, value of a
		// different column in same row. )
		if (source != null) {

			Generator g = source.getGenerator(gc.getWorkerID());

			// get cached value
			if (g instanceof TextAppendedWithDigit) {
				textAndDigit.append(((TextAppendedWithDigit) g)
						.getLastDigitValue());

				// recalculate value
			} else {
				// gc.setReference(currentRow, rows, rowStart, rowStop);
				source.getFieldValueForRow(gc, currentFieldValue);
				Object obj = currentFieldValue.getValue();
				// gc.revertReference();
				if (obj instanceof String) {
					String tmp = (String) obj;
					int cutstart = tmp.lastIndexOf(seperator);
					if (cutstart != -1) {
						textAndDigit.append(tmp.substring(cutstart + 1, tmp
								.length()));
					} else {
						textAndDigit.append(tmp);
					}
				} else if (obj instanceof Integer) {
					textAndDigit.append((Integer) obj);
				} else if (obj instanceof Long) {
					textAndDigit.append((Long) obj);
				} else {
					textAndDigit.append(obj.toString());
				}
			}
		}

		// append a digit from a defined intervall [min, max]
		if (min > Constants.INT_NOT_SET && max > Constants.INT_NOT_SET
				&& min < max) {
			int digitVal = (int) min
					+ getRandomNo(rng, gc, (int) (max - min + 1));
			textAndDigit.append(digitVal);
			if (cache) {
				lastDigitValue = digitVal;
			}
		}

		currentFieldValue.setValue(textAndDigit.toString());
	}

	private int getLastDigitValue() {

		return lastDigitValue;
	}

	/**
	 * returns a random number between 0 (inclusive and max (exclusive)
	 * 
	 * @param rng
	 *            the rng to use
	 * @param gc
	 *            gc for distribution (if needed)
	 * @param max
	 *            the maximum value (exclusive) in the output intervall
	 * @return random value between [0, max[
	 */
	public int getRandomNo(AbstractPDGFRandom rng, GenerationContext gc, int max) {

		if (getDistribution() == null) {
			return rng.nextInt(max);
		} else {
			return getDistribution().nextIntValue(rng, gc) % max;
		}

	}

	public void setText(String text) {
		this.text = text;
	}

	public String getText() {
		return text;
	}

	public void setDigitSource(String digitSource) {
		this.digitSource = digitSource;
	}

	public String getDigitSource() {
		return digitSource;
	}


	@Override
	protected void configParsers() throws XmlException {
		super.configParsers();
		getNodeParser(NODE_PARSER_min).setRequired(false).setUsed(true);
		getNodeParser(NODE_PARSER_max).setRequired(false).setUsed(true);
		addNodeParser(new TextNodeParser(true, true, this));
		addNodeParser(new CacheNodeParser(false, true, this));
		addNodeParser(new DigitSourceNodeParser(false, true, this));

	}

	private class TextNodeParser extends Parser<TextAppendedWithDigit> {

		public TextNodeParser(boolean isRequired, boolean b,
				TextAppendedWithDigit parent)  {
			super(isRequired, b, NODE_PARSER_text, parent,
					"Static text appended with a variable number (digit).");
		}

		@Override
		protected void parse(Node node) throws XmlException {
			String tmp = node.getTextContent();
			if (tmp != null && !tmp.isEmpty()) {
				setText(tmp);
			} else if (this.isRequired()) {
				throw new XmlException(getNodeInfo() + "<" + this.getName()
						+ "> must not be empty.");
			}
		}
	}

	private class DigitSourceNodeParser extends Parser<TextAppendedWithDigit> {

		public DigitSourceNodeParser(boolean isRequired, boolean b,
				TextAppendedWithDigit parent) {
			super(
					isRequired,
					b,
					NODE_PARSER_digitSrc,
					parent,
					"Digit taken from field specified by source. This digit is appended to the spcified static text.");
		}

		@Override
		protected void parse(Node node) throws XmlException {
			String tmp = node.getTextContent();
			if (tmp != null && !tmp.isEmpty()) {
				setDigitSource(tmp);
			} else if (this.isRequired()) {
				throw new XmlException(getNodeInfo() + "<" + this.getName()
						+ "> must not be empty.");
			}
		}
	}

	private class CacheNodeParser extends Parser<TextAppendedWithDigit> {

		public CacheNodeParser(boolean required, boolean b,
				TextAppendedWithDigit textAppendedWithDigit) {
			super(
					required,
					b,
					NODE_PARSER_cache,
					textAppendedWithDigit,
					"Specifies if digit value  x element [min, max] of this row should be cached for other Generators");

		}

		@Override
		protected void parse(Node node) throws XmlException {
			String nodeText = null;
			if (node == null || (nodeText = node.getTextContent()) == null
					|| nodeText.isEmpty()) {
				if (this.isRequired()) {
					throw new XmlException(getNodeInfo() + "<" + this.getName()
							+ "> must not be empty.");
				}
			} else {
				cache = Boolean.parseBoolean(nodeText);
			}
		}
	}
}
