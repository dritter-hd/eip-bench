/*******************************************************************************
 * Copyright (c) 2011, Chair of Distributed Information Systems, University of Passau. 
 * All rights reserved. 
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met: 
 * 
 * 1. Redistributions of source code must retain the above copyright notice, 
 *     this list of conditions and the following disclaimer. 
 * 
 * 2. Redistributions in binary form must reproduce the above copyright 
 *     notice, this list of conditions and the following disclaimer in the 
 *     documentation and/or other materials provided with the distribution. 
 * 
 * 3. Neither the name of the University of Passau nor the names of its 
 *     contributors may be used to endorse or promote products derived 
 *     from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 ******************************************************************************/
package tpc.h.generators;

import org.w3c.dom.Node;

import pdgf.core.FieldValueDTO;
import pdgf.core.dataGenerator.GenerationContext;
import pdgf.core.Parser;
import pdgf.core.exceptions.ConfigurationException;
import pdgf.core.exceptions.XmlException;
import pdgf.plugin.Generator;
import pdgf.plugin.AbstractPDGFRandom;

/**
 * 
 * @author Michael Frank
 * @version 1.0 08.06.2010
 */
public class TextAppendedWithDigit_O_Clerk extends Generator {

	public static final String NODE_PARSER_text = "text";
	public static final String NODE_PARSER_digitSrc = "digitSource";
	public static final String NODE_PARSER_cache = "cache";
	private final static char seperator = '#';
	private String text = "";
	private String digitSource = "";

	private long sf;
	private StringBuilder textAndDigit;
	private int constantPart;

	/*
	 * private ThreadLocal<StringBuilder> perThreadStringBuilder = new
	 * ThreadLocal<StringBuilder>() {
	 * 
	 * @Override protected StringBuilder initialValue() { return new
	 * StringBuilder(); } };
	 * 
	 * 
	 * 
	 * private ThreadLocal<Boolean> perThreadStringBuilderInitialized = new
	 * ThreadLocal<Boolean>() {
	 * 
	 * @Override protected Boolean initialValue() { return new Boolean(false); }
	 * };
	 */
	public TextAppendedWithDigit_O_Clerk() throws ConfigurationException, XmlException {
		super(
				"The notation text appended with digit [text, x] represents a string generated by concatenating the sub-string text, the character \"#\", and the sub-string representation of the number x.");
		// TODO Auto-generated constructor stub

	}

	@Override
	public synchronized void initialize(int workers)
			throws ConfigurationException, XmlException {
		// TODO Auto-generated method stub
		super.initialize(workers);
		// cache Scale factor
		sf = (long) getParent().getParent().getParent().getScaleFactor();

		// prefill static part!
		textAndDigit = new StringBuilder();
		textAndDigit.append(text);
		textAndDigit.append(seperator);
		constantPart = textAndDigit.length();

		/*
		 * if (!digitSource.isEmpty()) { Field f =
		 * this.getParentField().getParent().getField(digitSource); if(f == null){
		 * throw new XmlException(this.getNodeInfo() + "<" +
		 * NODE_PARSER_digitSrc +">  digit source or filed name  \"" +
		 * digitSource +"\" is unkonwn" ); }else{ source = f; } }
		 */

	}

	@Override
	public void nextValue(AbstractPDGFRandom rng, GenerationContext gc,
			FieldValueDTO currentFieldValue) {
		// StringBuilder textAndDigit = perThreadStringBuilder.get();
		/*
		 * Boolean initialized = perThreadStringBuilderInitialized.get();
		 * 
		 * if (!initialized) { textAndDigit.append(text);
		 * textAndDigit.append(seperator);
		 * perThreadStringBuilderInitialized.set(true); } else { // erase
		 * appendet digit value, keep static text + seperator
		 * textAndDigit.setLength(text.length() + 1); }
		 */

		// erase appendet digit value, keep static text + seperator
		textAndDigit.setLength(constantPart);

		long number = rng.nextLong();

		if (number < 0) {
			number = -number;
		}

		number = 1 + number % (sf * 1000);

		textAndDigit.append(String.format("%09d", number));

		currentFieldValue.setValue(textAndDigit.toString());
	}

	public void setText(String text) {
		this.text = text;
	}

	public String getText() {
		return text;
	}

	public void setDigitSource(String digitSource) {
		this.digitSource = digitSource;
	}

	public String getDigitSource() {
		return digitSource;
	}

	@Override
	protected void configParsers() throws XmlException {
		super.configParsers();
		
		addNodeParser(new TextNodeParser(true, true, this));

	}

	private class TextNodeParser extends Parser<TextAppendedWithDigit_O_Clerk> {

		public TextNodeParser(boolean isRequired, boolean isUsed,
				TextAppendedWithDigit_O_Clerk parent)  {
			super(isRequired, isUsed, NODE_PARSER_text, parent,
					"Static text appended with a variable number (digit).");
		}

		@Override
		protected void parse(Node node) throws XmlException {
			String tmp = node.getTextContent();
			if (tmp != null && !tmp.isEmpty()) {
				setText(tmp);
			} else if (this.isRequired()) {
				throw new XmlException(getNodeInfo() + "<" + this.getName()
						+ "> must not be empty.");
			}
		}
	}

}
